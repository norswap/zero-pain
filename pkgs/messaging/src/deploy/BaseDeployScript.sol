// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.20;

import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {Script, console} from "forge-std/Script.sol";

/**
 * @dev Base script to be inherited by other deploy scripts, providing functionality to record
 * information about the deployed contracts. After running the deploy script, this will output
 * two files: out/deployment.json and out/abiMap.json.
 *
 * out/deployment.json maps contract aliases (necessary because the same contract can be deployed
 * multiple times) to the deployed address.
 *
 * out/abiMap.json maps contract aliases to the contract names, which can be used for ABI lookups
 * (the ABIs themselves are generated by the makefile in out/abis.json and are keyed by contract
 * name).
 */
abstract contract BaseDeployScript is Script {
    /// Address of the multichain CREATE2 deterministic deployer (used by Foundry).
    address public constant CREATE2_DEPLOYER = 0x4e59b44847b379578588920cA78FbF26c0B4956C;

    /// @dev Identifies the deployment JSON to vm.serializeXXX and vm.writeJson functions.
    string internal constant deploymentJsonKey = "deployment_key";

    /// @dev Identifies the abi map JSON to vm.serializeXXX and vm.writeJson functions.
    string internal constant abiMapJsonKey = "abiMap_key";

    /// @dev Serialized deployment JSON.
    string internal deploymentJson = "";

    /// @dev Serialized abi map JSON.
    string internal abiMapJson = "";

    /// @dev Whether the deployment and abim map JSONs should be built.
    /// Can also be used by inheriting scripts for conditional logging.
    bool internal output = true;

    /// Disables ouptutting deployment info and possibly conditional logging.
    function dontOutput() public {
        output = false;
    }

    /**
     * Logs information about a deployed contract given an alias, the contract name and the
     * deployed address.
     *
     * @param contractAlias The alias of the contract, which will be keys in the emitted JSON files.
     * We use this because multiple copies of the same contract can be deployed.
     * @param contractName The name of the contract, to which the contract alias will be mapped in
     * the ABI map. Pass an empty string to signify no ABI mapping is desired.
     * @param deployedAddress The address of the deployed contract.
     */
    function deployed(string memory contractAlias, string memory contractName, address deployedAddress) internal {
        if (output) {
            deploymentJson = vm.serializeAddress(deploymentJsonKey, contractAlias, deployedAddress);
            if (bytes(contractName).length > 0) {
                abiMapJson = vm.serializeString(abiMapJsonKey, contractAlias, contractName);
            }
        }
    }

    /**
     * Same as `deployed(string,string,address)` with the contract alias set to the
     * contract name.
     */
    function deployed(string memory contractName, address deployedAddress) internal {
        deployed(contractName, contractName, deployedAddress);
    }

    /**
     * Writes the deployment and abi map JSON to out/deployment.json.
     * Automatically called by `run()`.
     */
    function writeDeploymentJson() internal {
        if (output) {
            vm.writeJson(deploymentJson, "./out/deployment.json");
            vm.writeJson(abiMapJson, "./out/abiMap.json");
        }
    }

    /**
     * This is where the deploy logic goes.
     *
     * vm.startBroadcast() and vm.stopBroadcast() are called before and after this.
     */
    function deploy() internal virtual {}

    /**
     * Returns the predicted address of a CREATE2 contract deployment using the CREATE2
     * deterministic deployer, given the entire creation code and a salt.
     */
    function getCreate2Address(bytes memory creationCode, bytes32 salt) internal pure returns (address payable) {
        return payable(
            address(
                uint160(
                    uint256(keccak256(abi.encodePacked(bytes1(0xff), CREATE2_DEPLOYER, salt, keccak256(creationCode))))
                )
            )
        );
    }

    /**
     * Returns the predicted address of a CREATE2 contract deployment using the CREATE2
     * deterministic deployer, given the creation code, the abi-encoded constructor arguments and a
     * salt.
     */
    function getCreate2Address(bytes memory creationCode, bytes memory constructorArgs, bytes32 salt)
        internal
        pure
        returns (address payable)
    {
        return getCreate2Address(abi.encodePacked(creationCode, constructorArgs), salt);
    }

    /**
     * Returns the size of the given contract.
     */
    function getContractSize(address addr) internal view returns (uint256 size) {
        assembly ("memory-safe") {
            size := extcodesize(addr)
        }
    }

    function _deployDeterministicCreationCode(bytes memory creationCode, bytes32 salt)
        internal
        returns (address payable addr)
    {
        assembly ("memory-safe") {
            addr := create2(0, add(creationCode, 0x20), mload(creationCode), salt)
        }
    }

    /**
     * Deploys a contract deterministically given its creation code, abi-encoded arguments and a
     * salt. This checks if the contract is already deployed, logs but succeeds if it is. This
     * automatically calls `deployed` with the provided contract alias and name, even if the
     * contract was already deployed.
     *
     * Example: `deployDeterministic("MockTokenA", "MockERC20", type(MockTokenA).creationCode, abi.encode("MockTokenA", "MTA", 18), 0)`
     *
     * @return (addr, deployed) The address of the contract and a boolean indicating
     *   if it is newly deployed by this call.
     */
    function deployDeterministic(
        string memory contractAlias,
        string memory contractName,
        bytes memory creationCode,
        bytes memory constructorArgs,
        bytes32 salt
    ) internal returns (address payable, bool) {
        address payable predictedAddress = getCreate2Address(creationCode, constructorArgs, salt);

        if (getContractSize(predictedAddress) > 0) {
            if (output) console.log("Contract already deployed", contractAlias, predictedAddress);
            deployed(contractAlias, contractName, predictedAddress);
            return (predictedAddress, false);
        }

        address payable addr = _deployDeterministicCreationCode(abi.encodePacked(creationCode, constructorArgs), salt);
        if (addr == address(0)) {
            if (output) console.log("Deploy failed", contractAlias);
            revert("Deploy failed");
        }

        deployed(contractAlias, contractName, addr);
        return (addr, true);
    }

    /**
     * Same as `deployDeterministic(string, string, bytes, bytes, bytes32)` but with the contract
     * alias set to the contract name.
     */
    function deployDeterministic(
        string memory contractName,
        bytes memory creationCode,
        bytes memory constructorArgs,
        bytes32 salt
    ) internal returns (address payable, bool) {
        return deployDeterministic(contractName, contractName, creationCode, constructorArgs, salt);
    }

    /**
     * Deploys a deterministic ERC1967 proxy for an implementation contract.
     * Uses LibClone to create the proxy with the same address across different networks.
     *
     * This checks if the proxy is already deployed, logs but succeeds if it is. This
     * automatically calls `deployed` with the provided contract alias and name, even if the
     * contract was already deployed.
     * Example: `deployProxy("Contract", "ContractImpl", implementation, abi.encodeCall(implementation.initialize, arg1, arg2), salt)`
     *
     * @param implementation The address of the implementation contract
     * @param initData The initialization data to be called on the proxy after deployment
     * @param salt The salt used for deterministic address generation
     * @return (proxy, deployed) The address of the proxy contract and a boolean indicating
     *   if it is newly deployed by this call.
     */
    function deployDeterministicProxy(
        string memory contractAlias,
        string memory contractName,
        address implementation,
        bytes memory initData,
        bytes32 salt
    ) internal returns (address, bool) {
        return deployDeterministic(
            contractAlias, contractName, type(ERC1967Proxy).creationCode, abi.encode(implementation, initData), salt
        );
    }

    /**
     * Same as `deployProxy(string, string, address, bytes, bytes32)` but with the contract
     * alias set to the contract name.
     */
    function deployDeterministicProxy(
        string memory contractAlias,
        address implementation,
        bytes memory initData,
        bytes32 salt
    ) internal returns (address, bool) {
        return deployDeterministic(
            contractAlias, contractAlias, type(ERC1967Proxy).creationCode, abi.encode(implementation, initData), salt
        );
    }

    /**
     * Runs the deploy logic â€” called by Foundry.
     * You can override this instead of `deploy` if you need to control the broadcast yourself.
     * Don't forget to call `writeDeploymentJson()`.
     */
    function run() external virtual {
        vm.startBroadcast();
        deploy();
        vm.stopBroadcast();
        writeDeploymentJson();
    }
}
